> 聊聊数据结构中的HashMap的结构和底层原理

```
数据结构，由数组和链表组合构成的数据结构;
数组里面每个地方都存了Key-Value这样的实例，在Java7叫Entry在Java8中叫Node;
因为他本身所有的位置都为null，在put插入的时候会根据key的hash去计算一个index值。

就比如我put（"china"，520），我插入了为”帅丙“的元素，这个时候我们会通过哈希函数计算出插入的位置，计算出来index是2那结果如下。

hash（"china"）= 2

```
> 你提到了还有链表，为啥需要链表，链表又是怎么样子的呢？

我们都知道数组长度是有限的，在有限的长度里面我们使用哈希，哈希本身就存在概率性，就是”帅丙“和”丙帅“我们都去hash有一定的概率会一样，就像上面的情况我再次哈希”丙帅“极端情况也会hash到一个值上，那就形成了链表。

每一个节点都会保存自身的hash、key、value、以及下个节点，我看看Node的源码。
>说到链表我想问一下，你知道新的Entry节点在插入链表的时候，是怎么插入的么？
java8之前是头插法，就是说新来的值会取代原有的值，原有的值就顺推到链表中去，就像上面的例子一样，因为写这个代码的作者认为后来的值被查找的可能性更大一点，提升查找的效率。

但是，在java8之后，都是所用尾部插入了。
>为啥改为尾部插入呢？
HashMap的扩容机制：

数组容量是有限的，数据多次插入的，到达一定的数量就会进行扩容，也就是resize。

>什么时候resize呢？

有两个因素：     

```
Capacity：HashMap当前长度。

LoadFactor：负载因子，默认值0.75f。
```
怎么理解呢，就比如当前的容量大小为100，当你存进第76个的时候，判断发现需要进行resize了，那就进行扩容，但是HashMap的扩容也不是简单的扩大点容量这么简单的。

>扩容？它是怎么扩容的呢？

分为两步

```
 扩容：创建一个新的Entry空数组，长度是原数组的2倍。
 
 ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。
```





